
\section{Implementation}

\subsection{Overview}

Our framework consists of 4 componments(Table \ref{table:componments}).
Each componment is designed to be replaceable.

\begin{table}[H]
  \renewcommand{\arraystretch}{1.3}
  \caption{Componments of the framework}
  \label{table:componments}
  \centering
  \begin{tabular}{ll}
     \hline
     \bfseries Name & \bfseries Purpose \\
     \hline
     Illuminate & Extented version of ROS Master \\ 
     Daemon     & In-container daemon \\
     Shadow     & Client-side utilities \\
     Middleman  & Handles address mapping from container to host \\
     \hline
  \end{tabular}
\end{table} 

To implement above features, the biggest problem is manitaining multiple active
instance of a specified ROS Service at same time.

ROS Master used a thread-safe dictionary to manitain the name-node mapping,
not allowing register multiple instance of ROS Service with same name.
Only the latest registered one is accessable via Master's \emph{lookupService} call.

We extented the original ROS Master to overcome these limitations(Fig.\ref{figure:illuminate}),
and named this variant as \emph{Illuminate}.
\begin{figure}[!t]
\centering
\includegraphics[width = \figwidth]{figures-1.pdf}
\caption{Architecture of System}
\label{figure:aoss}
\end{figure}

Instances are no longger ordinary \emph{ROS Nodes} in the \emph{ROS Graph},
but \emph{Cells} in their containers.

For clients of \emph{Illuminate}, as the only different between \emph{Master} and \emph{Illuminate}
is that the latter's Service register handling logic treats name crashes as normal requests, 
and built with load-balancing support.

While staying the protocol not modified, the original cline-side ROS installations just work as
usual without any extra configuration or modification.

However, for feature \ref{feature:fallback}, the traditional way of connecting current machine into ROS Graph,
setting up environment variable \emph{ROS\_MASTER\_API}), cannot help any more.
That's the direct motivatoin of introducing Shadow.
Shadow provides client-side support of Feature \ref{feature:mul}, \ref{feature:fallback}. 

Deamon and Middleman are implementation-related componment providing distributing support.
They watch, control the running of ROS Services, and provide exposed address to Illuminate.

\subsection{Containerizing ROS Service}
Both traditional virtualization and containerization(or sandbox) provides enough ablity to distribute any existing ROS Service.
Comparing with virtualization, containerization brings much less overhead. % TODO detail it

Docker, which is one of the most popular lightweight containerizing solution offically supported by ROS.
This method is developed mainly based on Docekr, but you can use it atop of many solutions with a tiny adapter. 

\subsection{Overriding ROS Master API}
The main techique used in tweaking these XML-RPC based APIs is proxying.
Within this extra intermediate, we intercept interested API calls,
and route the others to appropriate endpoint (see Table \ref{table:int}).

Generally, we intercept all API about Services so that we can modify the default behaviour of the register,
unregister and lookup of a Service.
However, for different componments, interested API can be different (Table \ref{table:int}).
These implementation related details are discussed in subsections for componment.
 
% TODO fullfill it
\begin{table}
    \renewcommand{\arraystretch}{1.3}
    \caption{Interested APIs in Different Componment}
    \label{table:interested-apis}
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        \bfseries Componment & \bfseries  API & \bfseries Purpose \\
        \hline
        \multirow{1}{*}{Illuminate} & lookupService & lookup Cells if no appropriate Node are found \\
        \hline
        \multirow{6}{*}{Daemon} & registerService & expose a Service to Illuminate\\
        \cline{2-3} & unregisterService & unregister current Cell \\
        \cline{2-3} & registerPublisher & \multirow{4}{*}{Simply intercept them} \\
        \cline{2-2} & registerSubscriber    &  \\
        \cline{2-2} & unregisterPublisher   &  \\
        \cline{2-2} & unregisterSubscriber  &  \\
        \hline
        \multirow{1}{*}{Shadow} & lookupService & apply above rules to dependency \\
        \hline
    \end{tabular}
\end{table} 

\subsection{Illuminate Details}

\begin{figure}[!t]
\centering
\includegraphics[width = \figwidth]{figures-3.pdf}
\caption{Architecture of Illuminate}
\label{figure:aoil}
\end{figure}

Illuminate creates a namespace to maintain all the Cells independent of
original ROS Services.

To maximum the compatiblity, Cells have lower priority than Services.

Illuminate owns all functionality of ROS Master,
extented it with 3 new APIs(Table \ref{table:illuminate-api}),
and adjusts the \emph{lookupService} function's logic.

All the 3 new APIs have exactly the same arguments and
return value like the Service version (Table \ref{table:illuminate-api}).

\begin{table}[H]
  \caption{New API in Illuminate}
  \label{table:illuminate-api}
  \centering
  \begin{tabular}{ll}
    \hline
    \bfseries Name & \bfseries Purpose \\
    \hline
    registerCell   & register Cells into registeration manager  \\
    unregisterCell & unregister Cells from registeration manager \\
    lookupCell     & lookup Cells, not exposed \\
    \hline
  \end{tabular}
\end{table} 



\subsubsection{Load Balancing}
Implementing load-balancing algorithms based on \emph{the real payload of each Cell} is overcomplicated.

To minimize the modification of original ROS, we decided to use the \emph{LRU} algorithm to detected which cell should be returned for current request, just like \emph{Nginx}'s default behaviour.

\subsection{Daemon and Middleman Details}

\begin{figure}[!t]
\centering
\includegraphics[width = \figwidth]{figures-5.pdf}
\caption{Architecture of Deamon and Middleman}
\label{figure:aodm}
\end{figure}

Deamon runs on each active container.
Its mainly function is handling the (un)register requests.
\begin{table}[H]
  \renewcommand{\arraystretch}{1.3}
  \caption{Deamon's behaviour}
  \label{table:demans-behaviour}
  \centering
  \begin{tabular}{|l|l|l|}
     \hline
     \bfseries \# & \bfseries API & \bfseries Behaviour \\
     \hline
     1 & registerService & expose current Service to Illuminate\\
     \hline
     2 & unregisterService & unregister current Service instance \\
     \hline
     3 & registerPublisher & \multirow{4}{*}{Simply intercept them} \\
     \cline{1-2}
     4 & registerSubscriber    &  \\
     \cline{1-2}
     5 & unregisterPublisher   &  \\
     \cline{1-2}
     6 & unregisterSubscriber  &  \\
     \hline
     7 & all the others & transmit to Illuminate \\
     \hline
  \end{tabular}
\end{table}

Outside container, Middleman handles container IP - host port mapping.

While each independent ROS Service will listen on random port on its
initializing process, transcendental method would not works any way. 

Current Docker releases has not included an introspect mechanism.

Engage the access from inside the Container to host is not a secure practice.

So we used a three-stage solution with a extra container running a Key-Value storage componment(Radis for this case).
\begin{enumerate}
    \item Register the mapped port to K-V storage right after container was created.
    \item Expose port 30000 for each Cells' container
    \item Redirect income requests from 30000 to listening port of the Service right after its initialization
\end{enumerate}

\subsection{Shadow Details}

\begin{figure}[!t]
\centering
\includegraphics[width = \figwidth]{figures-7.pdf}
\caption{Architecture of Shadow}
\label{figure:aosh}
\end{figure}

Finally, robots need clinet-side infrastructure to access Cells,
the Illuminate managed, independent namespace.

For different use cases, both original and customized client programs works.

\begin{table}
  \caption{ROS Compatiblity}
  \label{table:shadow-compatible}
  \centering
  \begin{tabular}{ll}
    \hline
    \bfseries Feature & \bfseries Origin ROS Compatiblity \\
    \hline
    Access Cells  & Yes  \\
    Configuration & No   \\
    Fallback      & No   \\
    \hline
  \end{tabular}
\end{table} 

\subsubsection{Accessing Cells}
As Services have higher priority than Cells, the `lookupService`

\subsubsection{Supporting Fallback}

\subsubsection{Configuration}
To discrbe a Service's usage and its lookup behaviour in
a client's perspective, we defined 3 properties, priority,
fallback and recursive(see table \ref{table:srv-opt}).

\begin{table}
  \renewcommand{\arraystretch}{1.3}
  \caption{Options to configure a ROS Service}
  \label{table:srv-opt}
  \centering
  \begin{tabular}{|l|l|l|}
    \hline
    \bfseries Name & \bfseries Possible values & \bfseries Meaning \\
    \hline
    \multirow{2}{*}{priority}  & Local  & use local Nondes first \\
    \cline{2-3}
                               & Remote & use remote Cells first \\
    \hline
    \multirow{3}{*}{fallback}  & True   & allowing fallback \\
    \cline{2-3}
                               & False  & disallowing fallback \\
    \cline{2-3}
                               & non-empty list of services & try  \\
    \hline
    \multirow{2}{*}{recursive} & True   & apply above rules to dependency \\
    \cline{2-3}
                               & False  & do not apply to dependency \\
    \hline
  \end{tabular}
\end{table} 

\subsubsection{Local Proxy}
Using the same techique of creating \emph{Daemon}, we created a lightweight
proxy of Illuminate, or ROS Master on client side, called \emph{Shadow}.

\subsubsection{Supporting private Nodes}
Just like Deamon intercept some register actions to keep only the Service itself is
correctly expose to Illuminate, Shadow intercepts all these requests and process them
on client-side.

When a package is directly or recursively marked as private, Shadows' lookup 
process only checks local Services, and all the (un)register is processed locally.



