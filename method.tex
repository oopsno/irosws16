\section{Methods}

Implementing above features, the biggest problem is manitaining multiple active instance of a specified ROS Service at same time.

That is, these instance are not \emph{ROS Nodes} in \emph{ROS Graph}, but \emph{Cells} in containers.

\subsection{Overriding ROS Master API}
How did I modified the original XML-RPC based protocol.

\subsection{Distributing ROS Service using Docker}
You can use any kind of technology to manage these containers.

\subsection{Managing multiple Nodes with same name}
\subsubsection{Mapping Container ID to host IP \& port}
While each independent ROS Service will listen on random port on it's initializing process, transcendental method would not works any way.

Running a Key-Value storage engine (Radis for this case) to hold ports mapping status.

\subsubsection{Load Balancing}
Implementing load-balancing algorithms based on \emph{the real payload of each Cell} is overcomplicated.

To minimize the modification of original ROS, we decided to use the \emph{LRU} algorithm to detected which cell should be returned for current request, just like \emph{Nginx}'s default behaviour.

\subsection{Supporting Fallback}
Configuration on how does one node works. 

\subsection{Supporting private Nodes}
Running a variant of ROS Master on each client.


