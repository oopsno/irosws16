\section{Methods}

To implement above features, the biggest problem is manitaining multiple active instance of a specified ROS Service at same time.

ROS Master does not allow register multiple instance of ROS Service with same \emph{Name}.
Only the latest registered one is accessable via Master's \emph{lookupService} call.

We extented the original ROS Master to overcome these limitations(Fig.\ref{figure:illuminate}). 

\begin{figure}[h]
\centering
\includegraphics{placeholder.1}
\caption{Architecture of Illuminate}
\label{figure:illuminate}
\end{figure}

That is, these instance are not \emph{ROS Nodes} in \emph{ROS Graph}, but \emph{Cells} in containers.

\subsection{Overriding ROS Master API}
How did I modified the original XML-RPC based protocol.

\subsection{Distributing ROS Service using Docker}
You can use any kind of technology to manage these containers.

\subsection{Managing multiple Nodes with same name}
\subsubsection{Mapping Container ID to host IP \& port}
While each independent ROS Service will listen on random port on its initializing process, transcendental method would not works any way. 

Current Docker releases has not included an introspect mechanism.

Engage the access from inside the Container to host is not a secure practice.

So we used a three-stage solution with a extra container running a Key-Value storage componment(Radis for this case).
\begin{enumerate}
    \item Register the mapped port to K-V storage right after container was created.
    \item Expose port 30000 for each Cells' container
    \item Redirect income requests from 30000 to listening port of the Service right after its initialization
\end{enumerate}

\subsubsection{Load Balancing}
Implementing load-balancing algorithms based on \emph{the real payload of each Cell} is overcomplicated.

To minimize the modification of original ROS, we decided to use the \emph{LRU} algorithm to detected which cell should be returned for current request, just like \emph{Nginx}'s default behaviour.

\subsection{Supporting Fallback}
Configuration on how does one node works. 

\subsubsection{Configuration}
To discrbe a Service's usage and its lookup behaviour in a client's perspective, we defined 3 properties, priority, fallback and recursive(see table \ref{table:srv-opt}).

\begin{table}
    \renewcommand{\arraystretch}{1.3}
    \caption{Options to configure a ROS Service}
    \label{table:srv-opt}
    \centering
    \begin{tabular}{|l|l|l|}
        \hline
        \bfseries Name & \bfseries Possible values & \bfseries Meaning \\
        \hline
        \multirow{2}{*}{priority}  & Local  & use local Nondes first \\
        \cline{2-3}
                                   & Remote & use remote Cells first \\
        \hline
        \multirow{3}{*}{fallback}  & True   & allowing fallback \\
        \cline{2-3}
                                   & False  & disallowing fallback \\
        \cline{2-3}
                                   & non-empty list of services & try  \\
        \hline
        \multirow{2}{*}{recursive} & True   & apply above rules to dependency \\
        \cline{2-3}
                                   & False  & do not apply to dependency \\
        \hline
    \end{tabular}
\end{table} 

\subsubsection{Local Proxy}
Using the same techique of creating \emph{Daemon}, we created a lightweight proxy of Illuminate, or ROS Master on client side, called \emph{Shadow}.

\subsection{Supporting private Nodes}
Running a variant of ROS Master on each client.


